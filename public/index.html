<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>OHOL Map</title>
  <link href="leaflet.css" rel="stylesheet" />
  <script type="text/javascript" src="leaflet.js"></script>
  <link href="L.SimpleGraticule.css" rel="stylesheet" />
  <script type="text/javascript" src="L.SimpleGraticule.js"></script>
  <link href="leaflet.timedimension.control.css" rel="stylesheet" />
  <script type="text/javascript" src="iso8601.js"></script>
  <script type="text/javascript" src="leaflet.timedimension.src.js"></script>
  <style>
body {
  background: white;
  color: black;
  width: 100%;
  height: 100%;
  position: absolute;
  overflow: hidden;
  margin: 0;
}

#map {
  width: 100%;
  height: 100%;
}

.birth {
  background-color: red;
  opacity: 0.5;
}
.wondible {
  background-color: blue;
  opacity: 0.5;
}
.trans {
  opacity: 0.4;
}
img {
  image-rendering: optimizeSpeed;             /*                     */
  image-rendering: -moz-crisp-edges;          /* Firefox             */
  image-rendering: -o-crisp-edges;            /* Opera               */
  image-rendering: -webkit-optimize-contrast; /* Chrome (and Safari) */
  image-rendering: optimize-contrast;         /* CSS3 Proposed       */
  -ms-interpolation-mode: nearest-neighbor;   /* IE8+                */
  }
  </style>
</head>

<body>
  <div id='map'></div>
</body>

<script type="text/javascript">
  var scale = Math.pow(2, 24)
  var crs = L.extend({}, L.CRS.Simple, {
    transformation: new L.transformation(1/scale, 0.5/scale, -1/scale, -0.5/scale)
  })
  var map = L.map('map', {
    crs: crs,
    maxBounds: [[-2147483648, -2147483648], [2147483647, 2147483647]],
    minZoom: 2,
    maxZoom: 27,
  })

  var base = {};

  base['Default'] = L.tileLayer('tiles/{z}/{x}/{y}.png', {
    errorTileUrl: 'ground_U.png',
    minZoom: 2,
    maxZoom: 27,
    //minNativeZoom: 24,
    maxNativeZoom: 24,
    attribution: '<a href="https://onehouronelife.com">Jason Rohrer</a> wondible',
  }).addTo(map)

  base['Faded'] = L.tileLayer('tiles/{z}/{x}/{y}.png', {
    errorTileUrl: 'ground_U.png',
    minZoom: 2,
    maxZoom: 27,
    //minNativeZoom: 24,
    maxNativeZoom: 24,
    opacity: 0.2,
    attribution: '<a href="https://onehouronelife.com">Jason Rohrer</a> wondible',
  })

  base['Crucible'] = L.tileLayer('crucible/{z}/{x}/{y}.png', {
    errorTileUrl: 'ground_U.png',
    minZoom: 2,
    maxZoom: 27,
    //minNativeZoom: 24,
    maxNativeZoom: 25,
    attribution: '<a href="https://onehouronelife.com">Jason Rohrer</a> wondible',
  });

  /*
  map.setView([-45120,-48760], 27)
  L.imageOverlay('brave.png', [[-45133, -48767.5],[-45106,-48735.5]], {
    className: 'xtrans',
    minZoom: 25,
  }).addTo(map);
  */

  map.setView([0,0], 17)

  var serverlist = [
    'bigserver1',
    'bigserver2',
    'server1',
    'server2',
    'server3',
    'server4',
    'server5',
    'server6',
    'server7',
    'server8',
    'server9',
    'server10',
    'server11',
    'server12',
    'server13',
    'server14',
    'server15',
    ]

  var birth = L.divIcon({className: 'birth'});
  var wondible = L.divIcon({className: 'wondible'});
  var overlays = {
    graticule: null,
    "48h Births": null,
    "48h Births Anim": null,
  }

  serverlist.forEach(function(server) {
    title = server + ' Monuments'
    overlays[title] = L.layerGroup();
    //fetch("data/" + server + ".onehouronelife.com_monuments.json").then(function(response) {
    fetch("http://localhost:5000/monuments?server_short=" + server).then(function(response) {
      response.json().then(function(wrapper){
        //console.log('monuments', wrapper)
        title = server + ' Monuments'
        var now = new Date()
        var data = wrapper.data
        data.forEach(function(point) {
          var date = new Date(point.date)
          var age = (now - date) / (24 * 60 * 60 * 1000)
          L.marker([point.y, point.x], {
              opacity: Math.max(0.4, Math.min(1.0, 1.0 - (age / (age+30))))
            })
            .bindPopup(point.date)
            .addTo(overlays[title])
          //L.circle([point.y, point.x], {radius: 21000, fill: false}).addTo(overlays[title])
        })
        if (server == 'bigserver2') {
          overlays[title].addTo(map);
          var last = data[data.length-1]
          map.setView([last.y, last.x], 17)
          }
      })
    })
  })



  var colormap = function(id) {
    return '#' + (((id * 49157) % 12582917).toString(16))
  }

  var colorhash = function(hash) {
    return '#' + hash.slice(0,6)
  }

  L.GridLayer.PointOverlay = L.GridLayer.extend({
    createTile: function (coords) {
      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      //console.log(tileSize)
      tile.setAttribute('width', tileSize.x);
      tile.setAttribute('height', tileSize.y);

      this.drawTile(tile, coords)

      return tile;
    },
    drawTile(tile, coords, time) {
      if (!this.options.data) {
        return
      }
      var tileSize = this.getTileSize();

      var ctx = tile.getContext('2d');
      ctx.clearRect(0, 0, tile.width, tile.height)
      var padding = 10

      var origin = L.point(coords.x * tileSize.x, coords.y * tileSize.y)
      var pnw = L.point(coords.x * tileSize.x - padding, coords.y * tileSize.y - padding)
      var pse = L.point(pnw.x + tileSize.x + padding*2, pnw.y + tileSize.y + padding*2)
      //console.log(coords, pnw, pse)
      llnw = crs.pointToLatLng(pnw, coords.z)
      llse = crs.pointToLatLng(pse, coords.z)
      //console.log(coords, llnw, llse)

      //var timebase = this.options.min
      //var timescale = this.options.max - timebase
      //var point = this.options.data[0]
      //var t = (point.birth_time - timebase) * 100 / timescale
      var fadeTime = 60*60
      this.options.data.forEach(function(point) {
        //console.log(point)

        if ( llnw.lng < point.birth_x && point.birth_x < llse.lng
          && llse.lat < point.birth_y && point.birth_y < llnw.lat) {
          if (time) {
            if (point.birth_time < (time - fadeTime) || time < point.birth_time) {
              return
            }

            var a = 1 - (time - point.birth_time) / fadeTime
            ctx.globalAlpha = a
          } else {
            ctx.globalAlpha = 0.5
          }
          var ll = L.latLng(point.birth_y, point.birth_x)
          var p = crs.latLngToPoint(ll, coords.z)
          //console.log(ll, p, pnw)
          p.x = p.x - origin.x
          p.y = p.y - origin.y
          //console.log(p)
          //var t = (point.birth_time - timebase) * 75 / timescale
          //ctx.fillStyle = "hsla(240, 100%, " + t + "%, " + a + ")"
          ctx.fillStyle = point.lineage
          var radius = 3
          if (point.chain == 1) {
            radius = 10
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, 2*Math.PI, false);
          ctx.fill();
        }
      })
    },
    updateTiles: function(ev) {
      var time = ev.time/1000
      for (key in this._tiles) {
        var tile = this._tiles[key]
        this.drawTile(tile.el, tile.coords, time)
      }
    },
  })


  var timeDimension = new L.TimeDimension({
    //timeInterval: start + "/" + end,
    //period: "PT1M",
  });
  // helper to share the timeDimension object between all layers
  map.timeDimension = timeDimension; 

  var player = new L.TimeDimension.Player({
    transitionTime: 100, 
    loop: false,
    startOver:true
  }, timeDimension);

  var timeDimensionControlOptions = {
    player: player,
    timeDimension: timeDimension,
    position: 'bottomleft',
    autoPlay: false,
    minSpeed: 1,
    speedStep: 0.5,
    maxSpeed: 30,
    timeSliderDragUpdate: true
  };

  var timeDimensionControl = new L.Control.TimeDimension(timeDimensionControlOptions);

  var pointOverlay = new L.GridLayer.PointOverlay()
  overlays["48h Births"] = pointOverlay

  var animOverlay = new L.GridLayer.PointOverlay({
    attribution: '<a href="https://github.com/socib/Leaflet.TimeDimension">socib/Leaflet.TimeDimension</a>',
  })
  timeDimension.on("timeload", animOverlay.updateTiles, animOverlay)
  overlays["48h Births Anim"] = animOverlay

  animOverlay.on('add', function(ev) {
    map.addControl(timeDimensionControl)
  })
  animOverlay.on('remove', function(ev) {
    map.removeControl(timeDimensionControl)
  })


  //fetch("data/bigserver2_points_48.json").then(function(response) {
  //fetch("data/EVE COLIN.json").then(function(response) {
  //fetch("data/bigserver2_points_hash.json").then(function(response) {
  fetch("http://localhost:5000/lives?server_id=17&period=P2D").then(function(response) {
    response.json().then(function(wrapper){
      //console.log('lives', wrapper)
      var min = null;
      var max = null;
      var data = wrapper.data;
      data.forEach(function(point) {
        if (min == null || point.birth_time < min) {
          min = point.birth_time
        }
        if (max == null || point.birth_time > max) {
          max = point.birth_time
        }
        point.lineage = colormap(point.lineage)
        if (point.hash) {
          point.hash = colorhash(point.hash)
        }
      })
      var times = []
      for (var t = min;t < max;t += 60) {
        times.push(t * 1000)
      }
      timeDimension.setAvailableTimes(times, 'replace')
      L.Util.setOptions(animOverlay, {
        data: data,
        min: min,
        max: max,
      })
      L.Util.setOptions(pointOverlay, {
        data: data,
        min: min,
        max: max,
      })
    })
  })

  /*
  fetch("data/recent.json").then(function(response) {
    response.json().then(function(data){
      data.forEach(function(point) {
        //L.marker([point[1], point[0]], {icon: wondible}).bindPopup(point[2]).addTo(map)
        L.marker([point[1], point[0]]).bindPopup(point[2]).addTo(map)
      })
    })
  })
  */

  //L.marker([0,0], {icon: icon}).addTo(map)

  var options = {
    showOriginLabel: false,
    redraw: 'move',
    attribution: '<a href="https://github.com/ablakey/Leaflet.SimpleGraticule">ablakey/SimpleGraticle</a>',
    zoomIntervals: [
      {start: 0,  end: 3,  interval: 1000000000},
      {start: 4,  end: 6,  interval: 100000000},
      {start: 7,  end: 9,  interval: 10000000},
      {start: 10, end: 13, interval: 1000000},
      {start: 14, end: 16, interval: 100000},
      {start: 17, end: 19, interval: 10000},
      {start: 20, end: 23, interval: 1000},
      {start: 24, end: 29, interval: 40},
    ]
  };

  var graticule = L.simpleGraticule(options)
  overlays['graticule'] = graticule

  L.control.layers(base, overlays).addTo(map);

  L.Control.Scale.include({
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters);
      var label = meters;
      if (meters < 1000) {
        label = meters;
      } else if (meters < 1000000) {
        label = (meters / 1000) + 'K';
      } else if (meters < 1000000000) {
        label = (meters / 1000000) + 'M';
      } else {
        label = (meters / 1000000000) + 'G';
      }

      label = label + ' z' + this._map.getZoom();

      this._updateScale(this._mScale, label, meters / maxMeters);
    }
  })
  L.control.scale({imperial: false}).addTo(map);

</script>
</html>

