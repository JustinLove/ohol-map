<!DOCTYPE HTML>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>OHOL Map</title>
  <link href="leaflet.css" rel="stylesheet" />
  <script type="text/javascript" src="leaflet.js"></script>
  <link href="L.SimpleGraticule.css" rel="stylesheet" />
  <script type="text/javascript" src="L.SimpleGraticule.js"></script>
  <link href="leaflet.timedimension.control.css" rel="stylesheet" />
  <script type="text/javascript" src="iso8601.js"></script>
  <script type="text/javascript" src="leaflet.timedimension.src.js"></script>
  <style>
body {
  background: white;
  color: black;
  width: 100%;
  height: 100%;
  position: absolute;
  overflow: hidden;
  margin: 0;
}

#map {
  width: 100%;
  height: 100%;
}

.birth {
  background-color: red;
  opacity: 0.5;
}
.wondible {
  background-color: blue;
  opacity: 0.5;
}
.trans {
  opacity: 0.8;
}
img {
  image-rendering: optimizeSpeed;             /*                     */
  image-rendering: -moz-crisp-edges;          /* Firefox             */
  image-rendering: -o-crisp-edges;            /* Opera               */
  image-rendering: -webkit-optimize-contrast; /* Chrome (and Safari) */
  image-rendering: optimize-contrast;         /* CSS3 Proposed       */
  -ms-interpolation-mode: nearest-neighbor;   /* IE8+                */
  }
  </style>
</head>

<body>
  <div id='map'></div>
</body>

<script type="text/javascript">
  var scale = Math.pow(2, 24)
  var crs = L.extend({}, L.CRS.Simple, {
    transformation: new L.transformation(1/scale, 0.5/scale, -1/scale, -0.5/scale)
  })
  var map = L.map('map', {
    crs: crs,
    maxBounds: [[-2147483648, -2147483648], [2147483647, 2147483647]],
    minZoom: 2,
    maxZoom: 27,
  })

  var base = {};

  base['Default'] = L.tileLayer('tiles/{z}/{x}/{y}.png', {
    errorTileUrl: 'ground_U.png',
    minZoom: 2,
    maxZoom: 27,
    //minNativeZoom: 24,
    maxNativeZoom: 24,
    attribution: '<a href="https://onehouronelife.com">Jason Rohrer</a> wondible',
  }).addTo(map);

  base['Crucible'] = L.tileLayer('crucible/{z}/{x}/{y}.png', {
    errorTileUrl: 'ground_U.png',
    minZoom: 2,
    maxZoom: 27,
    //minNativeZoom: 24,
    maxNativeZoom: 25,
    attribution: '<a href="https://onehouronelife.com">Jason Rohrer</a> wondible',
  });

  //L.imageOverlay('lineages_sample.png', [[-51653, -53592],[-41415,-42287]], {className: 'trans'}).addTo(map);

  map.setView([0,0], 17)

  var serverlist = [
    'bigserver1',
    'bigserver2',
    'server1',
    'server2',
    'server3',
    'server4',
    'server5',
    'server6',
    'server7',
    'server8',
    'server9',
    'server10',
    'server11',
    'server12',
    'server13',
    'server14',
    'server15',
    ]

  var birth = L.divIcon({className: 'birth'});
  var wondible = L.divIcon({className: 'wondible'});
  var overlays = {graticule: null}

  serverlist.forEach(function(server) {
    title = server + ' Monuments'
    overlays[title] = L.layerGroup();
    fetch("data/" + server + ".onehouronelife.com_monuments.json").then(function(response) {
      response.json().then(function(data){
        title = server + ' Monuments'
        data.forEach(function(point) {
          L.marker([point[1], point[0]]).bindPopup(point[2]).addTo(overlays[title])
          //L.circle([point[1], point[0]], {radius: 21000, fill: false}).addTo(overlays[title])
        })
        if (server == 'bigserver2') {
          overlays[title].addTo(map);
          var last = data[data.length-1]
          map.setView([last[1], last[0]], 17)
          }
      })
    })
  })


  var addTime = function(data, min, max) {
    var start = new Date(min * 1000)
    var end = new Date(max * 1000)
    var timeDimension = new L.TimeDimension({
      timeInterval: start + "/" + end,
      period: "PT1M",
    });
    // helper to share the timeDimension object between all layers
    map.timeDimension = timeDimension; 

    var player = new L.TimeDimension.Player({
      transitionTime: 100, 
      loop: false,
      startOver:true
    }, timeDimension);

    var timeDimensionControlOptions = {
      player: player,
      timeDimension: timeDimension,
      position: 'bottomleft',
      autoPlay: true,
      minSpeed: 1,
      speedStep: 0.5,
      maxSpeed: 30,
      timeSliderDragUpdate: true
    };

    var timeDimensionControl = new L.Control.TimeDimension(timeDimensionControlOptions);
    map.addControl(timeDimensionControl);

    var points = new L.GridLayer.PointOverlay({data: data, min: min, max: max}).addTo(map)
    timeDimension.on("timeload", points.updateTiles, points)
  }


  L.GridLayer.PointOverlay = L.GridLayer.extend({
    createTile: function (coords) {
      var tile = document.createElement('canvas');
      var tileSize = this.getTileSize();
      //console.log(tileSize)
      tile.setAttribute('width', tileSize.x);
      tile.setAttribute('height', tileSize.y);

      this.drawTile(tile, coords)

      return tile;
    },
    drawTile(tile, coords) {
      var tileSize = this.getTileSize();
      var time = this._map.timeDimension.getCurrentTime()/1000

      var ctx = tile.getContext('2d');
      //ctx.globalAlpha = 0.3
      ctx.clearRect(0, 0, tile.width, tile.height)

      var pnw = L.point(coords.x * tileSize.x, coords.y * tileSize.y)
      var pse = L.point(pnw.x + tileSize.x, pnw.y + tileSize.y)
      //console.log(coords, pnw, pse)
      llnw = crs.pointToLatLng(pnw, coords.z)
      llse = crs.pointToLatLng(pse, coords.z)
      //console.log(coords, llnw, llse)

      var timebase = this.options.min
      var timescale = this.options.max - timebase
      //var point = this.options.data[0]
      //var t = (point[2] - timebase) * 100 / timescale
      var fadeTime = 60*60
      this.options.data.forEach(function(point) {
        //console.log(point)

        if ( llnw.lng < point[0] && point[0] < llse.lng
          && llse.lat < point[1] && point[1] < llnw.lat
          && (time - fadeTime) < point[2] && point[2] < (time)) {
          var ll = L.latLng(point[1], point[0])
          var p = crs.latLngToPoint(ll, coords.z)
          //console.log(ll, p, pnw)
          p.x = p.x - pnw.x
          p.y = p.y - pnw.y
          //console.log(p)
          var a = 1 - (time - point[2]) / fadeTime
          //var t = (point[2] - timebase) * 75 / timescale
          //ctx.fillStyle = "hsla(240, 100%, " + t + "%, " + a + ")"
          var radius = 3
          if (point[3] == 1) {
            ctx.fillStyle = "hsla(90, 100%, 50%, " + a + ")"
            radius = 5
          } else {
            ctx.fillStyle = "hsla(240, 100%, 50%, " + a + ")"
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, 2*Math.PI, false);
          ctx.fill();
        }
      })
    },
    updateTiles: function() {
      for (key in this._tiles) {
        var tile = this._tiles[key]
        this.drawTile(tile.el, tile.coords)
      }
    },
  })


  L.AnimLayer = L.TimeDimension.Layer.extend({
    _onNewTimeLoading: function(ev) {
        // to be implemented for each type of layer
        this.fire('timeload', {
            time: ev.time
        });
        return;
    },

    isReady: function(time) {
        // to be implemented for each type of layer
        return true;
    },

    _update: function() {
        this._baselayer.options.time = this._timeDimension.getCurrentTime();
        this._baseLayer.redraw()
        this._currentLayer = this._baseLayer
        return true;
    },

  })


  fetch("data/bigserver2_points_day.json").then(function(response) {
    response.json().then(function(data){
      var min = null;
      var max = null;
      var times = []
      data.forEach(function(point) {
        if (min == null || point[2] < min) {
          min = point[2]
        }
        if (max == null || point[2] > max) {
          max = point[2]
        }
        times.push(point[2])
      })
      addTime(data, min, max)
    })
  })

  /*
  fetch("data/METALLO.json").then(function(response) {
    response.json().then(function(data){
      data.forEach(function(point) {
        L.marker([point[1], point[0]], {icon: birth}).bindPopup(point[2]).addTo(map)
        //L.marker([point[1], point[0]]).bindPopup(point[2]).addTo(map)
      })
    })
  })
  */

  /*
  fetch("data/recent.json").then(function(response) {
    response.json().then(function(data){
      data.forEach(function(point) {
        //L.marker([point[1], point[0]], {icon: wondible}).bindPopup(point[2]).addTo(map)
        L.marker([point[1], point[0]]).bindPopup(point[2]).addTo(map)
      })
    })
  })
  */

  //L.marker([0,0], {icon: icon}).addTo(map)

  var options = {
    showOriginLabel: false,
    redraw: 'move',
    attribution: '<a href="https://github.com/ablakey/Leaflet.SimpleGraticule">ablakey/SimpleGraticle</a>',
    zoomIntervals: [
      {start: 0,  end: 3,  interval: 1000000000},
      {start: 4,  end: 6,  interval: 100000000},
      {start: 7,  end: 9,  interval: 10000000},
      {start: 10, end: 13, interval: 1000000},
      {start: 14, end: 16, interval: 100000},
      {start: 17, end: 19, interval: 10000},
      {start: 20, end: 23, interval: 1000},
      {start: 24, end: 29, interval: 40},
    ]
  };

  var graticule = L.simpleGraticule(options)
  overlays['graticule'] = graticule

  L.control.layers(base, overlays).addTo(map);

  L.Control.Scale.include({
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters);
      var label = meters;
      if (meters < 1000) {
        label = meters;
      } else if (meters < 1000000) {
        label = (meters / 1000) + 'K';
      } else if (meters < 1000000000) {
        label = (meters / 1000000) + 'M';
      } else {
        label = (meters / 1000000000) + 'G';
      }

      label = label + ' z' + this._map.getZoom();

      this._updateScale(this._mScale, label, meters / maxMeters);
    }
  })
  L.control.scale({imperial: false}).addTo(map);

</script>
</html>

